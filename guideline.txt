INTERACTIVE 3D CITY DESIGNER - PROJECT DOCUMENTATION

SECTION 1: CODE FILE STRUCTURE AND COMPONENT ANALYSIS

The project follows a modular architecture with clear separation of concerns across multiple directories:

Project Root Structure:
- src/: Contains all source code organized by functionality
- assets/: Stores texture files (building.jpg, tower.png, skyscraper.jpg, road.jpg, pond.jpg)
- bin/: Output directory for compiled executable
- include/: External library headers (stb_image.h for texture loading)

Core Source Organization:

src/main.cpp - Application Entry Point
This file serves as the program's central controller, handling:
- OpenGL context initialization using GLFW and GLEW
- Shader compilation with embedded vertex and fragment shader source code
- User input collection for city customization (city size, building types, dimensions)
- Main rendering loop with event handling for mouse controls
- Camera setup and window management for fullscreen display

src/algorithms/ - Procedural Generation Algorithms
algorithms.h/cpp implement two fundamental computer graphics algorithms:
- Bresenham Line Algorithm: Generates discrete pixel coordinates for road placement
- Midpoint Circle Algorithm: Creates circular boundary points for pond generation
These algorithms convert continuous mathematical shapes into discrete grid coordinates suitable for 3D world placement.

src/meshes/ - 3D Geometry Generation
mesh.h/cpp provides GPU-ready mesh construction:
- makeCube(): Creates textured cube geometry with proper normals and UV coordinates
- makeQuadXZ(): Generates ground plane quads for roads and terrain
- makeCircleFan(): Constructs circular mesh geometry for pond rendering
Each mesh includes vertex positions, surface normals for lighting, and texture coordinates.

src/render/ - Rendering Pipeline Components
shader.h/cpp: Manages OpenGL shader programs with uniform variable setting capabilities
texture.h/cpp: Handles image loading using stb_image library with proper OpenGL texture binding
camera.h/cpp: Implements orbit camera system with mouse-controlled rotation and zoom functionality

src/scene/ - World Composition and Layout
city_scene.h/cpp contains the core city generation logic:
- Grid-based spatial management for object placement
- Collision detection system preventing object overlaps
- Texture management for different building types
- Procedural layout generation combining algorithms with 3D rendering

SECTION 2: FUNDAMENTAL CONCEPTS AND ALGORITHMS

Computer Graphics Algorithms Implementation:

Bresenham Line Algorithm Concept:
This algorithm efficiently determines which discrete grid cells should be filled to approximate a continuous line between two points. It uses only integer arithmetic and avoids floating-point calculations, making it ideal for real-time applications. The algorithm incrementally decides whether to move horizontally, vertically, or diagonally based on accumulated error terms.

Midpoint Circle Algorithm Concept:
Also known as Bresenham's circle algorithm, this technique generates circle points by exploiting 8-fold symmetry. It calculates points in one octant and mirrors them to create a complete circle. The algorithm uses decision variables to determine the next pixel position, maintaining circular accuracy while using only integer operations.

3D Graphics Pipeline Concepts:

Vertex Transformation Pipeline:
The rendering system transforms 3D vertices through multiple coordinate spaces:
- Model coordinates: Local object space where meshes are defined
- World coordinates: Global 3D scene space after model transformations
- View coordinates: Camera-relative space for perspective projection
- Screen coordinates: Final 2D pixel positions for rasterization

Texture Mapping Implementation:
Each 3D surface receives 2D texture coordinates (UV mapping) that correspond to image pixel locations. The GPU interpolates these coordinates across triangle surfaces, allowing detailed surface appearance without complex geometry. Different building types use separate textures (concrete, brick, glass) for visual variety.

Lighting Model:
The shader implements Phong lighting with three components:
- Ambient: Base illumination simulating indirect light bouncing
- Diffuse: Directional lighting based on surface normal and light direction
- Specular: Reflective highlights creating material shine effects

Collision Detection System:
A 2D boolean grid tracks occupied spatial regions, preventing object placement conflicts. Each building reserves a 5x5 grid area, while smaller objects use proportionally smaller reservations. This approach ensures realistic spacing and prevents visual overlapping.

SECTION 3: DETAILED IMPLEMENTATION WITH CODE ANALYSIS

Basic OpenGL Lines Implementation:

The road system uses Bresenham's algorithm to generate discrete grid coordinates, then converts each coordinate to a 3D quad:

```cpp
// src/scene/city_scene.cpp - Line 108
// Generate road coordinates using Bresenham
auto road1 = bresenhamLine(5, center, gridSize-5, center);
auto road2 = bresenhamLine(center, 5, center, gridSize-5);

// src/scene/city_scene.cpp - Line 295
// Convert each grid cell to world coordinates and render
for (auto &c : roadCells) {
    auto w = cellToWorld(c.first, c.second);
    glm::mat4 m = glm::translate(glm::mat4(1.0f), glm::vec3(w.first, 0.02f, w.second));
    if (c.first == center) { // Rotate texture for vertical roads
        m = glm::rotate(m, glm::radians(90.0f), glm::vec3(0.0f, 1.0f, 0.0f));
    }
}
```

Bresenham Line Algorithm Implementation:

```cpp
// src/algorithms/algorithms.cpp - Line 4
std::vector<std::pair<int,int>> bresenhamLine(int x0, int y0, int x1, int y1) {
    std::vector<std::pair<int,int>> pts;
    int dx = abs(x1 - x0);
    int sx = (x0 < x1) ? 1 : -1;
    int dy = -abs(y1 - y0);
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx + dy;
    int x = x0, y = y0;
    while (true) {
        pts.emplace_back(x,y);
        if (x==x1 && y==y1) break;
        int e2 = 2*err;
        if (e2 >= dy) { err += dy; x += sx; }
        if (e2 <= dx) { err += dx; y += sy; }
    }
    return pts;
}
```

The algorithm maintains an error term that determines when to step in each direction. The decision variables dx and dy represent the line's slope components, while sx and sy indicate step directions.

Midpoint Circle Algorithm Implementation:

```cpp
// src/algorithms/algorithms.cpp - Line 22
std::vector<std::pair<int,int>> midpointCircle(int cx, int cy, int r) {
    std::vector<std::pair<int,int>> pts;
    int x = r, y = 0;
    int dx = 1 - (r << 1);
    int dy = 0, err = 0;
    while (x >= y) {
        // Generate 8 symmetric points
        pts.emplace_back(cx + x, cy + y);
        pts.emplace_back(cx + y, cy + x);
        pts.emplace_back(cx - y, cy + x);
        pts.emplace_back(cx - x, cy + y);
        pts.emplace_back(cx - x, cy - y);
        pts.emplace_back(cx - y, cy - x);
        pts.emplace_back(cx + y, cy - x);
        pts.emplace_back(cx + x, cy - y);
        
        y++;
        err += dy;
        dy += 2;
        if ((err << 1) + dx > 0) {
            x--;
            err += dx;
            dx += 2;
        }
    }
    return pts;
}
```

This implementation calculates one octant and uses 8-fold symmetry to generate complete circle points. The decision parameter determines whether to move diagonally or maintain the current x-coordinate.

3D Model with Texture Mapping Implementation:

Building rendering combines mesh geometry with texture application:

```cpp
// src/scene/city_scene.cpp - Line 330
// Bind appropriate texture based on building type
GLuint currentTex = 0;
if (type == 0) currentTex = skyscraperTex;      // Glass/concrete
else if (type == 1) currentTex = towerTex;     // Brick texture
else currentTex = buildingTex;                 // Office building

glBindTexture(GL_TEXTURE_2D, currentTex);

// Apply transformations and render
float width = (type == 0) ? config.skyscraperWidth : 
              (type == 1) ? config.towerWidth : config.buildingWidth;
glm::mat4 m = glm::translate(glm::mat4(1.0f), glm::vec3(w.first, height/2.0f, w.second));
m = glm::scale(m, glm::vec3(width, height, depth));
shader.setMat4("model", m);
shader.setVec3("baseColor", glm::vec3(1.0f, 1.0f, 1.0f));
shader.setFloat("useTexture", currentTex ? 1.0f : 0.0f);
```

The cube mesh includes proper UV coordinates for texture mapping:

```cpp
// src/meshes/mesh.cpp - Line 25
// Cube vertex data with position, normal, and UV coordinates
float V[] = {
    // front face
    -0.5f,-0.5f,0.5f,   0,0,1,  0,0,  // bottom-left
     0.5f,-0.5f,0.5f,   0,0,1,  1,0,  // bottom-right
     0.5f, 0.5f,0.5f,   0,0,1,  1,1,  // top-right
    -0.5f, 0.5f,0.5f,   0,0,1,  0,1,  // top-left
};
```

Collision Detection System Implementation:

The grid-based collision system prevents object overlapping:

```cpp
// src/scene/city_scene.cpp - Line 86
bool CityScene::isGridCellFree(int x, int z, int size) const {
    for (int i = x - size/2; i <= x + size/2; i++) {
        for (int j = z - size/2; j <= z + size/2; j++) {
            if (i < 0 || i >= gridSize || j < 0 || j >= gridSize || occupiedGrid[i][j]) {
                return false;
            }
        }
    }
    return true;
}

// src/scene/city_scene.cpp - Line 96
void CityScene::markGridCells(int x, int z, int size) {
    for (int i = x - size/2; i <= x + size/2; i++) {
        for (int j = z - size/2; j <= z + size/2; j++) {
            if (i >= 0 && i < gridSize && j >= 0 && j < gridSize) {
                occupiedGrid[i][j] = true;
            }
        }
    }
}

// src/scene/city_scene.cpp - Line 155
// Building placement uses this system to ensure proper spacing
for (int attempts = 0; attempts < 100 && !validPos; attempts++) {
    x = 5 + rand() % (gridSize - 10);
    z = 5 + rand() % (gridSize - 10);
    
    if (isGridCellFree(x, z, 5)) {  // Check 5x5 area for buildings
        validPos = true;
        markGridCells(x, z, 5);     // Reserve the space
    }
}nt x, int z, int size) {
    for (int i = x - size/2; i <= x + size/2; i++) {
        for (int j = z - size/2; j <= z + size/2; j++) {
            if (i >= 0 && i < gridSize && j >= 0 && j < gridSize) {
                occupiedGrid[i][j] = true;
            }
        }
    }
}
```

Building placement uses this system to ensure proper spacing:

```cpp
// Find valid position using collision detection
for (int attempts = 0; attempts < 100 && !validPos; attempts++) {
    x = 5 + rand() % (gridSize - 10);
    z = 5 + rand() % (gridSize - 10);
    
    if (isGridCellFree(x, z, 5)) {  // Check 5x5 area for buildings
        validPos = true;
        markGridCells(x, z, 5);     // Reserve the space
    }
}
```

This approach ensures buildings maintain realistic separation distances while preventing visual conflicts. The system scales collision areas based on object types: buildings use 5x5 areas, trees use 3x3 areas, and smaller objects use single cells.

Texture Mapping Process Overview:

Texture mapping transforms 2D images into realistic 3D surface materials through a multi-stage pipeline. The stb_image library loads common image formats and converts them to GPU-compatible pixel data. Different building types receive specific texture assignments: skyscrapers use concrete textures, towers use brick patterns, and office buildings use stone materials.

UV coordinate mapping links 3D surface points to 2D texture pixels using normalized coordinates (0.0 to 1.0). The GPU interpolates these coordinates across triangle surfaces for smooth texture application. The shader system combines texture sampling with Phong lighting calculations, producing realistic material appearance that responds to scene lighting.

Texture filtering and wrapping parameters prevent visual artifacts like pixelation, maintaining consistent surface quality across viewing distances and angles.

The complete implementation demonstrates how classical computer graphics algorithms integrate with modern OpenGL rendering to create interactive 3D environments. The modular design allows independent development of algorithms, rendering systems, and scene composition while maintaining clean interfaces between components.