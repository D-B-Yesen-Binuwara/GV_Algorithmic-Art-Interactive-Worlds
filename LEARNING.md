# Interactive 3D City Designer - Complete Learning Guide

## üéØ High-Level Rendering Pipeline Flow

### **Overview of the Rendering Process**

The 3D city rendering follows this pipeline:

1. **Initialization** ‚Üí **Scene Generation** ‚Üí **Mesh Creation** ‚Üí **Texture Loading** ‚Üí **Rendering Loop**

```
User Input ‚Üí Algorithm Generation ‚Üí 3D Mesh Creation ‚Üí GPU Upload ‚Üí Frame Rendering
```

### **File Responsibilities in the Pipeline**

| **Stage** | **Files Responsible** | **Purpose** |
|-----------|----------------------|-------------|
| **Application Setup** | `main.cpp` (lines 76-95) | Initialize OpenGL, create window, setup shaders |
| **Algorithm Generation** | `algorithms.cpp` (lines 4-47) | Generate road/pond coordinates using mathematical algorithms |
| **3D Geometry Creation** | `mesh.cpp` (lines 27-95) | Convert coordinates to 3D meshes with vertices, normals, UV coordinates |
| **Texture Management** | `texture.cpp` (lines 5-24) | Load images and convert to GPU textures |
| **Scene Composition** | `city_scene.cpp` (lines 108-150) | Combine algorithms + meshes + textures into final scene |
| **Camera Control** | `camera.cpp` (lines 5-34) | Handle user interaction and viewpoint calculation |
| **Frame Rendering** | `city_scene.cpp` (lines 280-450) | Draw all objects each frame with proper transformations |

---

## üìê Core Implementation Details

### **1. Drawing OpenGL Lines (Roads)**

**Concept**: Roads are not drawn as lines, but as sequences of textured quads (rectangles) placed at coordinates generated by Bresenham's algorithm.

**Process Flow**:
```
Bresenham Algorithm ‚Üí Grid Coordinates ‚Üí World Coordinates ‚Üí 3D Quads ‚Üí Textured Roads
```

**Code Implementation**:

```cpp
// File: src/algorithms/algorithms.cpp, Lines 4-19
std::vector<std::pair<int,int>> bresenhamLine(int x0, int y0, int x1, int y1) {
    std::vector<std::pair<int,int>> pts;
    int dx = abs(x1 - x0);           // Horizontal distance
    int sx = (x0 < x1) ? 1 : -1;     // Step direction (left/right)
    int dy = -abs(y1 - y0);          // Vertical distance (negative)
    int sy = (y0 < y1) ? 1 : -1;     // Step direction (up/down)
    int err = dx + dy;               // Error accumulator
    int x = x0, y = y0;              // Current position
    
    while (true) {
        pts.emplace_back(x,y);       // Store current grid cell
        if (x==x1 && y==y1) break;  // Reached destination
        int e2 = 2*err;              // Double the error for comparison
        if (e2 >= dy) { err += dy; x += sx; }  // Step horizontally
        if (e2 <= dx) { err += dx; y += sy; }  // Step vertically
    }
    return pts;
}
```

**Road Generation**:
```cpp
// File: src/scene/city_scene.cpp, Lines 108-113
int center = gridSize / 2;
// Create horizontal road across city center
auto road1 = bresenhamLine(5, center, gridSize-5, center);
// Create vertical road across city center  
auto road2 = bresenhamLine(center, 5, center, gridSize-5);
```

**Road Rendering**:
```cpp
// File: src/scene/city_scene.cpp, Lines 295-310
for (auto &c : roadCells) {
    auto w = cellToWorld(c.first, c.second);  // Convert grid to world coordinates
    glm::mat4 m = glm::translate(glm::mat4(1.0f), glm::vec3(w.first, 0.02f, w.second));
    
    // Rotate texture for vertical roads to align road markings
    if (c.first == center) { 
        m = glm::rotate(m, glm::radians(90.0f), glm::vec3(0.0f, 1.0f, 0.0f));
    }
    
    shader.setMat4("model", m);  // Apply transformation
    shader.setVec3("baseColor", glm::vec3(0.2f, 0.2f, 0.2f)); // Dark asphalt color
}
```

### **2. 3D Transformations and Translations**

**Concept**: Every 3D object goes through a series of mathematical transformations to position, rotate, and scale it in the world.

**Transformation Pipeline**:
```
Local Coordinates ‚Üí Model Matrix ‚Üí World Coordinates ‚Üí View Matrix ‚Üí Camera Space ‚Üí Projection Matrix ‚Üí Screen Space
```

**Building Transformation Example**:
```cpp
// File: src/scene/city_scene.cpp, Lines 360-365
float width = config.skyscraperWidth;  // User-defined width
float height = buildingHeights[i];     // Calculated height
float depth = width * 0.9f;           // Proportional depth

// Create transformation matrix
glm::mat4 m = glm::translate(glm::mat4(1.0f), glm::vec3(w.first, height/2.0f, w.second));
m = glm::scale(m, glm::vec3(width, height, depth));
shader.setMat4("model", m);  // Send to GPU
```

**Matrix Operations Explained**:
- `glm::mat4(1.0f)` - Creates identity matrix (no transformation)
- `glm::translate()` - Moves object to world position
- `glm::scale()` - Resizes object to desired dimensions
- `glm::rotate()` - Rotates object around an axis

**Camera Transformation**:
```cpp
// File: src/render/camera.cpp, Lines 5-10
glm::vec3 Camera::position() const {
    glm::vec3 dir;
    dir.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));    // Horizontal rotation
    dir.y = sin(glm::radians(pitch));                             // Vertical angle
    dir.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));   // Depth rotation
    return target - dir * distance;  // Calculate camera position relative to target
}
```

### **3. Bresenham's Line Drawing Algorithm**

**Mathematical Concept**: Determines which discrete grid cells should be filled to approximate a continuous line between two points using only integer arithmetic.

**Why It's Used**: 
- Avoids floating-point calculations (faster)
- Produces visually smooth lines on discrete grids
- Perfect for converting mathematical lines to game world coordinates

**Algorithm Breakdown**:
```cpp
// File: src/algorithms/algorithms.cpp, Lines 4-19
int dx = abs(x1 - x0);     // Total horizontal distance
int dy = -abs(y1 - y0);    // Total vertical distance (negative for calculation)
int err = dx + dy;         // Initial error term

// The error term decides when to step diagonally vs. straight
int e2 = 2*err;
if (e2 >= dy) { err += dy; x += sx; }  // Move horizontally
if (e2 <= dx) { err += dx; y += sy; }  // Move vertically
```

**Visual Example**:
```
From (0,0) to (3,2):
Step 1: (0,0) ‚Üí (1,0)  [horizontal step]
Step 2: (1,0) ‚Üí (2,1)  [diagonal step]  
Step 3: (2,1) ‚Üí (3,2)  [diagonal step]
```

### **4. Circle Drawing Algorithm (Midpoint Circle)**

**Mathematical Concept**: Generates circle points by calculating one octant and using 8-fold symmetry to create a complete circle.

**Why It's Used**:
- Efficient: Only calculates 1/8 of the circle
- Integer-only arithmetic
- Perfect circles without gaps

**Algorithm Implementation**:
```cpp
// File: src/algorithms/algorithms.cpp, Lines 22-47
std::vector<std::pair<int,int>> midpointCircle(int cx, int cy, int r) {
    int x = r, y = 0;                    // Start at rightmost point
    int dx = 1 - (r << 1);              // Decision parameter for x
    int dy = 0, err = 0;                 // Decision parameter for y
    
    while (x >= y) {                     // Only calculate one octant
        // Generate 8 symmetric points for each calculated point
        pts.emplace_back(cx + x, cy + y);  // Octant 1
        pts.emplace_back(cx + y, cy + x);  // Octant 2
        pts.emplace_back(cx - y, cy + x);  // Octant 3
        pts.emplace_back(cx - x, cy + y);  // Octant 4
        pts.emplace_back(cx - x, cy - y);  // Octant 5
        pts.emplace_back(cx - y, cy - x);  // Octant 6
        pts.emplace_back(cx + y, cy - x);  // Octant 7
        pts.emplace_back(cx + x, cy - y);  // Octant 8
        
        // Decision logic for next point
        y++;
        err += dy; dy += 2;
        if ((err << 1) + dx > 0) {
            x--; err += dx; dx += 2;
        }
    }
}
```

**Pond Creation**:
```cpp
// File: src/scene/city_scene.cpp, Lines 52-54
auto pondWorld = cellToWorld(pond_cx, pond_cy);
pondMesh = makeCircleFan(pondWorld.first, pondWorld.second, (float)pond_r, 64);
```

### **5. Color Assignment System**

**Background/Window Color**:
```cpp
// File: src/main.cpp, Line 195
glClearColor(0.05f, 0.05f, 0.15f, 1.0f); // Dark night sky (R, G, B, Alpha)
```

**Ground Plane Color**:
```cpp
// File: src/scene/city_scene.cpp, Lines 285-290
shader.setVec3("baseColor", glm::vec3(0.1f, 0.15f, 0.1f)); // Dark grass at night
```

**Building Colors by Type**:
```cpp
// File: src/scene/city_scene.cpp, Lines 240-248
glm::vec3 CityScene::getFuturisticColor(int type) {
    switch (type) {
        case 0: return glm::vec3(0.7f, 0.7f, 0.8f); // Light gray concrete (skyscrapers)
        case 1: return glm::vec3(0.6f, 0.5f, 0.4f); // Brown brick (towers)
        case 2: return glm::vec3(0.8f, 0.8f, 0.7f); // Beige stone (office buildings)
        default: return glm::vec3(0.6f, 0.6f, 0.6f);
    }
}
```

**Street Lamp Lighting**:
```cpp
// File: src/scene/city_scene.cpp, Lines 425-430
shader.setVec3("baseColor", glm::vec3(1.0f, 0.9f, 0.6f)); // Warm street light color
```

### **6. Texture Mapping Implementation**

**Texture Loading Process**:
```cpp
// File: src/render/texture.cpp, Lines 5-24
GLuint loadTexture(const std::string& path) {
    int w, h, comp;                                    // Width, height, components
    stbi_set_flip_vertically_on_load(true);           // Flip for OpenGL coordinate system
    unsigned char* data = stbi_load(path.c_str(), &w, &h, &comp, 3); // Load image data
    
    GLuint tex;
    glGenTextures(1, &tex);                           // Generate texture ID
    glBindTexture(GL_TEXTURE_2D, tex);                // Bind for operations
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, data); // Upload to GPU
    glGenerateMipmap(GL_TEXTURE_2D);                  // Generate smaller versions for distance
    
    // Set texture parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);    // Repeat horizontally
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);    // Repeat vertically
    
    stbi_image_free(data);                            // Free CPU memory
    return tex;                                       // Return GPU texture ID
}
```

**Texture Application to Buildings**:
```cpp
// File: src/scene/city_scene.cpp, Lines 340-355
// Select texture based on building type
GLuint currentTex = 0;
if (type == 0) currentTex = skyscraperTex;      // Glass/concrete texture
else if (type == 1) currentTex = towerTex;     // Brick texture  
else currentTex = buildingTex;                 // Office building texture

glBindTexture(GL_TEXTURE_2D, currentTex);      // Activate texture
shader.setFloat("useTexture", currentTex ? 1.0f : 0.0f); // Tell shader to use texture
shader.setInt("tex", 0);                       // Texture unit 0
```

**UV Coordinate Mapping**:
```cpp
// File: src/meshes/mesh.cpp, Lines 30-37
// Each vertex includes UV coordinates (last 2 numbers)
float V[] = {
    // Position (x,y,z)    Normal (x,y,z)   UV (u,v)
    -0.5f,-0.5f,0.5f,      0,0,1,           0,0,    // Bottom-left corner
     0.5f,-0.5f,0.5f,      0,0,1,           1,0,    // Bottom-right corner
     0.5f, 0.5f,0.5f,      0,0,1,           1,1,    // Top-right corner
    -0.5f, 0.5f,0.5f,      0,0,1,           0,1,    // Top-left corner
};
```

### **7. Random Generation of Lampposts and Trees**

**Lamppost Placement Logic**:
```cpp
// File: src/scene/city_scene.cpp, Lines 200-220
void CityScene::placeStreetLamps() {
    streetLamps.clear();
    int center = gridSize / 2;
    
    // Place lamps along horizontal road every 6 grid units
    for (int i = 8; i < gridSize - 8; i += 6) {
        if (abs(i - center) > 3) {  // Avoid road intersection
            // Place on both sides of road
            if (center + 2 < gridSize && isGridCellFree(i, center + 2)) {
                streetLamps.push_back({i, center + 2});
                markGridCells(i, center + 2);  // Mark as occupied
            }
            if (center - 2 >= 0 && isGridCellFree(i, center - 2)) {
                streetLamps.push_back({i, center - 2});
                markGridCells(i, center - 2);
            }
        }
    }
}
```

**Tree Placement System**:
```cpp
// File: src/scene/city_scene.cpp, Lines 180-200
void CityScene::placeTrees() {
    treeCells.clear();
    srand(54321);  // Fixed seed prevents objects from moving between frames
    
    int numTrees = config.citySize * 8;  // More trees for larger cities
    
    for (int i = 0; i < numTrees; i++) {
        int x, z;
        bool validPos = false;
        
        // Try up to 50 times to find valid position
        for (int attempts = 0; attempts < 50 && !validPos; attempts++) {
            x = 3 + rand() % (gridSize - 6);  // Random position with border
            z = 3 + rand() % (gridSize - 6);
            
            if (isGridCellFree(x, z, 3)) {    // Check 3x3 area is free
                validPos = true;
            }
        }
        
        if (validPos) {
            treeCells.push_back({x, z});
            markGridCells(x, z, 3);  // Reserve 3x3 area
        }
    }
}
```

**Tree Rendering**:
```cpp
// File: src/scene/city_scene.cpp, Lines 385-400
for (auto &tree : treeCells) {
    auto w = cellToWorld(tree.first, tree.second);
    
    // Tree trunk (brown cylinder)
    glm::mat4 trunk = glm::translate(glm::mat4(1.0f), glm::vec3(w.first, 1.0f, w.second));
    trunk = glm::scale(trunk, glm::vec3(0.3f, 2.0f, 0.3f));
    shader.setVec3("baseColor", glm::vec3(0.4f, 0.2f, 0.1f)); // Brown
    
    // Tree foliage (green sphere)
    glm::mat4 leaves = glm::translate(glm::mat4(1.0f), glm::vec3(w.first, 2.5f, w.second));
    leaves = glm::scale(leaves, glm::vec3(1.5f, 1.5f, 1.5f));
    shader.setVec3("baseColor", glm::vec3(0.1f, 0.6f, 0.1f)); // Green
}
```

### **8. Building and Pond Location System**

**Grid-Based Collision Detection**:
```cpp
// File: src/scene/city_scene.cpp, Lines 86-95
bool CityScene::isGridCellFree(int x, int z, int size) const {
    // Check if area around position is free
    for (int i = x - size/2; i <= x + size/2; i++) {
        for (int j = z - size/2; j <= z + size/2; j++) {
            if (i < 0 || i >= gridSize || j < 0 || j >= gridSize || occupiedGrid[i][j]) {
                return false;  // Position is occupied or out of bounds
            }
        }
    }
    return true;  // Area is free
}
```

**Building Placement Algorithm**:
```cpp
// File: src/scene/city_scene.cpp, Lines 150-180
void CityScene::placeBuildingsRandomly() {
    srand(12345);  // Fixed seed for consistent layout
    
    for (int i = 0; i < config.numBuildings; i++) {
        int x, z;
        bool validPos = false;
        
        // Try up to 100 times to find valid position
        for (int attempts = 0; attempts < 100 && !validPos; attempts++) {
            x = 5 + rand() % (gridSize - 10);  // Random position with border
            z = 5 + rand() % (gridSize - 10);
            
            if (isGridCellFree(x, z, 5)) {     // Check 5x5 area for building
                validPos = true;
            }
        }
        
        if (validPos) {
            buildingCells.push_back({x, z});
            markGridCells(x, z, 5);  // Reserve 5x5 area
            
            // Assign building type and height
            buildingTypes.push_back(determineBuildingType(i));
            buildingHeights.push_back(getFuturisticHeight(type, i));
        }
    }
}
```

**Pond Location**:
```cpp
// File: src/scene/city_scene.cpp, Lines 130-135
// Place pond offset from city center
pond_cx = center + 8; 
pond_cy = center - 8; 
pond_r = (int)config.pondRadius;  // User-defined radius
```

### **9. Collision Detection System**

**Grid-Based Occupancy System**:
```cpp
// File: src/scene/city_scene.cpp, Lines 35-40
// Initialize 2D boolean grid
occupiedGrid = std::vector<std::vector<bool>>(gridSize, std::vector<bool>(gridSize, false));
```

**Marking Occupied Areas**:
```cpp
// File: src/scene/city_scene.cpp, Lines 96-105
void CityScene::markGridCells(int x, int z, int size) {
    // Mark rectangular area as occupied
    for (int i = x - size/2; i <= x + size/2; i++) {
        for (int j = z - size/2; j <= z + size/2; j++) {
            if (i >= 0 && i < gridSize && j >= 0 && j < gridSize) {
                occupiedGrid[i][j] = true;  // Mark cell as occupied
            }
        }
    }
}
```

**Circular Collision for Pond**:
```cpp
// File: src/scene/city_scene.cpp, Lines 135-145
// Mark circular pond area as occupied
for (int i = std::max(0, pond_cx - pond_r); i <= std::min(gridSize-1, pond_cx + pond_r); i++) {
    for (int j = std::max(0, pond_cy - pond_r); j <= std::min(gridSize-1, pond_cy + pond_r); j++) {
        int dx = i - pond_cx;
        int dy = j - pond_cy;
        if (dx*dx + dy*dy <= pond_r*pond_r) {  // Inside circle
            occupiedGrid[i][j] = true;
        }
    }
}
```

---

## üõ†Ô∏è How to Modify the System

### **1. Changing Plane/Background/Window Colors**

**Window Background Color**:
```cpp
// File: src/main.cpp, Line 195
// Change these RGB values (0.0 to 1.0 range)
glClearColor(0.05f, 0.05f, 0.15f, 1.0f); 
// Example: Sunset sky
glClearColor(0.8f, 0.4f, 0.2f, 1.0f);
```

**Ground Plane Color**:
```cpp
// File: src/scene/city_scene.cpp, Line 289
// Change ground color
shader.setVec3("baseColor", glm::vec3(0.1f, 0.15f, 0.1f)); 
// Example: Desert sand
shader.setVec3("baseColor", glm::vec3(0.8f, 0.7f, 0.5f));
```

### **2. Changing Texture Mapping**

**Replace Texture Files**:
1. Replace image files in `assets/` folder:
   - `building.jpg` ‚Üí Your building texture
   - `road.jpg` ‚Üí Your road texture
   - `pond.jpg` ‚Üí Your water texture

**Add New Texture Types**:
```cpp
// File: src/scene/city_scene.cpp, Lines 60-70
// Add new texture loading
GLuint newTexture = loadTexture("assets/new_texture.jpg");

// File: src/scene/city_scene.cpp, Lines 340-350
// Use new texture for specific building type
if (type == 3) currentTex = newTexture;  // New building type
```

### **3. Relocating Road and Pond**

**Change Road Layout**:
```cpp
// File: src/scene/city_scene.cpp, Lines 108-113
// Modify road positions
int center = gridSize / 2;
// Diagonal road example
auto road1 = bresenhamLine(0, 0, gridSize-1, gridSize-1);
// Multiple parallel roads
auto road2 = bresenhamLine(5, center-5, gridSize-5, center-5);
auto road3 = bresenhamLine(5, center+5, gridSize-5, center+5);
```

**Change Pond Location**:
```cpp
// File: src/scene/city_scene.cpp, Lines 130-135
// Move pond to different location
pond_cx = gridSize / 4;      // Left side of city
pond_cy = gridSize / 4;      // Front of city
pond_r = (int)config.pondRadius;
```

### **4. Lamppost Location and Spacing**

**Change Lamppost Spacing**:
```cpp
// File: src/scene/city_scene.cpp, Line 205
// Change spacing from 6 to different value
for (int i = 8; i < gridSize - 8; i += 12) {  // Wider spacing
```

**Change Lamppost Distance from Road**:
```cpp
// File: src/scene/city_scene.cpp, Lines 207-215
// Change distance from road center (currently +/- 2)
if (center + 4 < gridSize && isGridCellFree(i, center + 4)) {  // Further from road
    streetLamps.push_back({i, center + 4});
}
```

**Add Lampposts to Different Roads**:
```cpp
// File: src/scene/city_scene.cpp, Lines 200-230
// Add lampposts to custom road coordinates
for (auto &roadCell : customRoadCells) {
    if (isGridCellFree(roadCell.first + 1, roadCell.second)) {
        streetLamps.push_back({roadCell.first + 1, roadCell.second});
    }
}
```

### **5. Grid Size Change (City Size Modification)**

**Modify Grid Size Calculation**:
```cpp
// File: src/scene/city_scene.cpp, Lines 35-40
// Change size multipliers
gridSize = (citySize == 1) ? 30 : (citySize == 2) ? 50 : 80;  // Smaller cities
// Or
gridSize = (citySize == 1) ? 80 : (citySize == 2) ? 120 : 200; // Larger cities
```

**Adjust Object Counts for New Size**:
```cpp
// File: src/scene/city_scene.cpp, Line 185
// Scale tree count with city size
int numTrees = config.citySize * 12;  // More trees per size level

// File: src/scene/city_scene.cpp, Lines 150-160
// Adjust building placement borders for larger cities
x = 10 + rand() % (gridSize - 20);  // Larger border for big cities
```

**Update Camera Distance for Larger Cities**:
```cpp
// File: src/main.cpp, Lines 175-180
// Adjust initial camera distance based on city size
float initialDistance = 50.0f + (citySize * 30.0f);
camera.distance = initialDistance;
```

### **6. Adding New Building Types**

**Define New Building Type**:
```cpp
// File: src/scene/city_scene.cpp, Lines 240-250
// Add case for new building type
glm::vec3 CityScene::getFuturisticColor(int type) {
    switch (type) {
        case 0: return glm::vec3(0.7f, 0.7f, 0.8f); // Skyscrapers
        case 1: return glm::vec3(0.6f, 0.5f, 0.4f); // Towers  
        case 2: return glm::vec3(0.8f, 0.8f, 0.7f); // Office buildings
        case 3: return glm::vec3(0.9f, 0.8f, 0.6f); // New: Residential buildings
        default: return glm::vec3(0.6f, 0.6f, 0.6f);
    }
}
```

**Add New Texture for Building Type**:
```cpp
// File: src/scene/city_scene.cpp, Lines 60-70
// Load new texture
GLuint residentialTex = loadTexture("assets/residential.jpg");

// File: src/scene/city_scene.cpp, Lines 340-350
// Assign texture to new building type
if (type == 3) currentTex = residentialTex;
```

This comprehensive guide covers all major aspects of the 3D city rendering system, from low-level algorithms to high-level scene composition, with specific code examples and modification instructions for customization.